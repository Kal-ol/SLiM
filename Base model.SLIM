// ============================================================
//  3-pop nonWF hybrid model
//   (1) 2-locus BDMI haplotype fitness table
//   (2) Utility functions (modular style)
//   (3) p1 x p2 hybrids migrate to p3; p3 reproduces clonally
//   (4) Competition baseline plus genotype-dependent incompatibilities
//  Notes:
//   - No &, |, &&, ||
//   - Utility functions are top-level
//   - No nested function declarations
//   - No-arg functions use (void)
// ============================================================


//////////////////////////////
//  UTILITY FUNCTIONS
//////////////////////////////

// One-locus direct-selection multiplier given derived allele count n (0/1/2)
function (numeric) oneLocusMult(integer n)
{
    if (n == 0) return 1.0;
    if (n == 1) return 1.0 + h*s;
    return 1.0 + s;
}

// Add derived allele mutation at a position if not already present
function (void) addAllele(object<Haplosome> g, object<MutationType> mt, integer pos)
{
    muts = g.mutationsOfType(mt);
    if (size(muts) > 0) {
        if (sum(muts.position == pos) > 0) {
            return;
        }
    }
    g.addNewDrawnMutation(mt, pos);
}

// Count derived allele copies (0,1,2) at a focal locus
function (integer) countDerived(object<Individual> ind, object<MutationType> mt, integer pos)
{
    n = 0;

    m1 = ind.genome1.mutationsOfType(mt);
    if (size(m1) > 0) {
        if (sum(m1.position == pos) > 0) n = n + 1;
    }

    m2 = ind.genome2.mutationsOfType(mt);
    if (size(m2) > 0) {
        if (sum(m2.position == pos) > 0) n = n + 1;
    }

    return n;
}

// Haplotype index for a single genome:
//  1 = A1B1 (no A2, no B2)
//  2 = A1B2 (no A2, yes B2)
//  3 = A2B1 (yes A2, no B2)
//  4 = A2B2 (yes A2, yes B2)
function (integer) hapIndex(object<Haplosome> g)
{
    hasA2 = F;
    hasB2 = F;

    a = g.mutationsOfType(mA2);
    if (size(a) > 0) {
        if (sum(a.position == posA) > 0) hasA2 = T;
    }

    b = g.mutationsOfType(mB2);
    if (size(b) > 0) {
        if (sum(b.position == posB) > 0) hasB2 = T;
    }

    if (hasA2) {
        if (hasB2) return 4;
        return 3;
    }

    if (hasB2) return 2;
    return 1;
}

// Direct selection multiplier by ORLEACH_MODE
function (numeric) directSelectionMultiplier(object<Individual> ind)
{
    if (ORLEACH_MODE == 0) return 1.0;

    nA2 = countDerived(ind, mA2, posA);
    nB2 = countDerived(ind, mB2, posB);

    if (ORLEACH_MODE == 1) {
        if (ind.subpopulation == p1) return oneLocusMult(nA2);
        if (ind.subpopulation == p2) return oneLocusMult(nB2);
        return 1.0;
    }

    // ORLEACH_MODE == 2
    return oneLocusMult(nA2) * oneLocusMult(nB2);
}

// Orleach haplotype-pair BDMI multiplier
function (numeric) orleachBDMIMultiplier(object<Individual> ind)
{
    i = hapIndex(ind.genome1);
    j = hapIndex(ind.genome2);

    if (i > j) {
        tmp = i;
        i = j;
        j = tmp;
    }

    one_hs = 1.0 + h*s;
    one_s  = 1.0 + s;

    e_single = (1.0 - hb*sb);
    e_double = (1.0 - hb*kb*sb);
    e_full   = (1.0 - sb);

    if (ORLEACH_MODE == 0) {
        one_hs = 1.0;
        one_s  = 1.0;
    }

    w = 1.0;

    if (i == 1) {
        if (j == 1) w = 1.0;
        else if (j == 2) w = 1.0;
        else if (j == 3) w = one_hs;
        else if (j == 4) w = one_hs * e_double;
    }
    else if (i == 2) {
        if (j == 2) w = 1.0;
        else if (j == 3) w = one_hs * e_double;
        else if (j == 4) w = one_hs * e_single;
    }
    else if (i == 3) {
        if (j == 3) w = one_s;
        else if (j == 4) w = one_s * e_single;
    }
    else if (i == 4) {
        if (j == 4) w = one_s * e_full;
    }

    return w;
}

// Migrate individuals in p1,p2 with migrateToP3 == T into p3
function (void) migrateFlaggedHybrids(void)
{
    migrants = c();

    for (ind in c(p1.individuals, p2.individuals)) {
        flag = ind.getValue("migrateToP3");
        if (!isNULL(flag)) {
            if (flag) migrants = c(migrants, ind);
        }
    }

    if (size(migrants) > 0) {
        p3.takeMigrants(migrants);
        for (ind in migrants) ind.setValue("migrateToP3", F);
    }
}

// Competition baseline into fitnessScaling
function (void) applyCompetition(numeric K1, numeric K2, numeric K3)
{
    if (p1.individualCount > 0) {
        comp = c_p1 * (
            (p1.individualCount / K1) +
            alpha_p1_p2 * (p2.individualCount / K2) +
            alpha_pX_p3 * (p3.individualCount / K3)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p1.individuals) ind.fitnessScaling = base;
    }

    if (p2.individualCount > 0) {
        comp = c_p2 * (
            (p2.individualCount / K2) +
            alpha_p2_p1 * (p1.individualCount / K1) +
            alpha_pX_p3 * (p3.individualCount / K3)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p2.individuals) ind.fitnessScaling = base;
    }

    if (p3.individualCount > 0) {
        comp = c_p3 * (
            (p3.individualCount / K3) +
            alpha_p3_p1 * (p1.individualCount / K1) +
            alpha_p3_p2 * (p2.individualCount / K2)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p3.individuals) ind.fitnessScaling = base;
    }
}

// Apply Orleach multipliers: fitnessScaling *= w_dir * w_bdmi
function (void) applyOrleachBDMI(void)
{
    for (pop in sim.subpopulations) {
        for (ind in pop.individuals) {
            w_dir  = directSelectionMultiplier(ind);
            w_bdmi = orleachBDMIMultiplier(ind);

            ind.setValue("w_bdmi", w_bdmi);

            ind.fitnessScaling = ind.fitnessScaling * w_dir * w_bdmi;
            if (ind.fitnessScaling < 0.01) ind.fitnessScaling = 0.01;
        }
    }
}


//////////////////////////////
//  MODEL INITIALIZE
//////////////////////////////

initialize()
{
    initializeSLiMModelType("nonWF");
    initializeSLiMOptions(keepPedigrees=F);

    // Genome: two focal loci
    defineConstant("L", 100000);
    defineConstant("posA", 20000);
    defineConstant("posB", 70000);

    // Derived alleles:
    //  - mA2 present at posA means A2 (wild-type absence = A1)
    //  - mB2 present at posB means B2 (wild-type absence = B1)
    initializeMutationType("mA2", 0.5, "f", 0.0);
    initializeMutationType("mB2", 0.5, "f", 0.0);
    mA2.convertToSubstitution = F;
    mB2.convertToSubstitution = F;

    initializeGenomicElementType("g1", c(mA2, mB2), c(0.5, 0.5));
    initializeGenomicElement(g1, 0, L-1);

    // Freeze genetics
    defineConstant("MU", 0.0);
    initializeMutationRate(MU);
    initializeRecombinationRate(1e-3);

    // Demography
    defineConstant("K_total", 2500.0);

    defineConstant("K_prop_p1", 0.38375);
    defineConstant("K_prop_p2", 0.38375);
    defineConstant("K_prop_p3", 0.23250);

    defineConstant("maxOvules_p1p2", 12);
    defineConstant("maxOvules_p3",   7);
    defineConstant("hybridizationRate", 0.05);

    // Density dependence
    defineConstant("dd_rate0", 0.75);
    defineConstant("dd_c",     2.0);
    defineConstant("dd_floor", 0.01);

    // Competition coefficients
    defineConstant("alpha_p1_p2", 0.0);
    defineConstant("alpha_p2_p1", 0.0);
    defineConstant("alpha_pX_p3", 0.0);
    defineConstant("alpha_p3_p1", 0.0);
    defineConstant("alpha_p3_p2", 0.0);

    defineConstant("c_p1", 0.3);
    defineConstant("c_p2", 0.3);
    defineConstant("c_p3", 0.5);

    // Survival filter
    defineConstant("surv_k", 3.0);
    defineConstant("surv_theta", 0.6);

    // Orleach-like parameters
    defineConstant("s",  0.10);
    defineConstant("h",  0.50);

    defineConstant("sb", 0.30);
    defineConstant("hb", 0.50);
    defineConstant("kb", 1.00);

    // 0 = epistasis only; 1 = p1 selected on A2, p2 selected on B2; 2 = symmetric
    defineConstant("ORLEACH_MODE", 1);

    // Runtime
    defineConstant("T_max", 150);

    // Logging
    defineConstant("OUTFILE", "output_orleach_bdmi.txt");
}


//////////////////////////////
//  SETUP POPS + GENOTYPES
//////////////////////////////

1 early()
{
    sim.addSubpop("p1", 100);
    sim.addSubpop("p2", 150);
    sim.addSubpop("p3", 0);

    writeFile(OUTFILE,
        "gen\tN1\tN2\tN3\tmeanW_p1\tmeanW_p2\tmeanW_p3\tmeanBDMI_p3\tK1\tK2\tK3\n",
        append=F);

    // Parent 1 = AAbb  => A2 fixed, B2 absent
    for (ind in p1.individuals) {
        addAllele(ind.genome1, mA2, posA);
        addAllele(ind.genome2, mA2, posA);
        ind.setValue("age", 0);
    }

    // Parent 2 = aaBB  => B2 fixed, A2 absent
    for (ind in p2.individuals) {
        addAllele(ind.genome1, mB2, posB);
        addAllele(ind.genome2, mB2, posB);
        ind.setValue("age", 0);
    }
}


//////////////////////////////
//  REPRODUCTION
//////////////////////////////

reproduction()
{
    totalPop = p1.individualCount + p2.individualCount + p3.individualCount;
    density  = totalPop / K_total;

    fertilizationRate = max(dd_rate0 * exp(-dd_c * density), dd_floor);
    clonalSuccessRate = max(dd_rate0 * exp(-dd_c * density), dd_floor);

    if (totalPop >= K_total) return;

    // p1: sexual; sometimes hybridize with p2
    if (subpop == p1) {
        n = min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10);
        for (i in seqLen(n)) {

            doHybrid = F;
            if (p2.individualCount > 0) {
                if (runif(1) < hybridizationRate) doHybrid = T;
            }

            if (doHybrid) {
                mate = sample(p2.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("isHybrid", T);
                kid.setValue("migrateToP3", T);
                kid.setValue("hybridSource", "p1_female_x_p2_male");
                kid.setValue("age", 0);
            } else {
                mate = sample(p1.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("age", 0);
            }
        }
        return;
    }

    // p2: sexual; sometimes hybridize with p1
    if (subpop == p2) {
        n = min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10);
        for (i in seqLen(n)) {

            doHybrid = F;
            if (p1.individualCount > 0) {
                if (runif(1) < hybridizationRate) doHybrid = T;
            }

            if (doHybrid) {
                mate = sample(p1.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("isHybrid", T);
                kid.setValue("migrateToP3", T);
                kid.setValue("hybridSource", "p2_female_x_p1_male");
                kid.setValue("age", 0);
            } else {
                mate = sample(p2.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("age", 0);
            }
        }
        return;
    }

    // p3: clonal only
    if (subpop == p3) {
        n = min(rbinom(1, maxOvules_p3, clonalSuccessRate), 10);
        for (i in seqLen(n)) {
            kid = subpop.addCloned(individual);
            kid.setValue("isHybrid", T);
            kid.setValue("age", 0);
        }
        return;
    }
}


//////////////////////////////////////////////////////
//  EARLY: migrate + compute per-gen fitnessScaling
//////////////////////////////////////////////////////

early()
{
    migrateFlaggedHybrids();

    K1 = K_total * K_prop_p1;
    K2 = K_total * K_prop_p2;
    K3 = K_total * K_prop_p3;

    applyCompetition(K1, K2, K3);
    applyOrleachBDMI();

    sim.setValue("K1", K1);
    sim.setValue("K2", K2);
    sim.setValue("K3", K3);
}


//////////////////////////////////////////////////////
//  SURVIVAL: nonWF viability step
//////////////////////////////////////////////////////

survival(p1)
{
    w = individual.fitnessScaling;
    p_surv = 1.0 / (1.0 + exp(-surv_k * (w - surv_theta)));
    return p_surv;
}


//////////////////////////////////////////////////////
//  LATE: age update + logging + stop
//////////////////////////////////////////////////////

late()
{
    for (ind in sim.subpopulations.individuals) {
        a = ind.getValue("age");
        if (isNULL(a)) a = 0;
        ind.setValue("age", a + 1);
    }

    meanW1 = 0.0;
    if (p1.individualCount > 0) meanW1 = mean(p1.individuals.fitnessScaling);

    meanW2 = 0.0;
    if (p2.individualCount > 0) meanW2 = mean(p2.individuals.fitnessScaling);

    meanW3 = 0.0;
    if (p3.individualCount > 0) meanW3 = mean(p3.individuals.fitnessScaling);

    meanBDMIp3 = 0.0;
    if (p3.individualCount > 0) {
        sumBD = 0.0;
        for (ind in p3.individuals) {
            v = ind.getValue("w_bdmi");
            if (isNULL(v)) v = 1.0;
            sumBD = sumBD + v;
        }
        meanBDMIp3 = sumBD / p3.individualCount;
    }

    K1 = sim.getValue("K1");
    K2 = sim.getValue("K2");
    K3 = sim.getValue("K3");

    writeFile(OUTFILE,
        sim.cycle + "\t" +
        p1.individualCount + "\t" +
        p2.individualCount + "\t" +
        p3.individualCount + "\t" +
        meanW1 + "\t" + meanW2 + "\t" + meanW3 + "\t" +
        meanBDMIp3 + "\t" + K1 + "\t" + K2 + "\t" + K3 + "\n",
        append=T);

    if (sim.cycle >= T_max) sim.simulationFinished();
}
