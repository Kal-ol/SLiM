// utility functions

function (numeric) oneLocusMult(integer n)
{
    if (n == 0) return 1.0;
    if (n == 1) return 1.0 + h*s;
    return 1.0 + s;
}

function (void) addAllele(object<Haplosome> g, object<MutationType> mt, integer pos)
{
    muts = g.mutationsOfType(mt);
    if (size(muts) > 0) {
        if (sum(muts.position == pos) > 0) return;
    }
    g.addNewDrawnMutation(mt, pos);
}

function (integer) countDerived(object<Individual> ind, object<MutationType> mt, integer pos)
{
    n = 0;

    m1 = ind.genome1.mutationsOfType(mt);
    if (size(m1) > 0) {
        if (sum(m1.position == pos) > 0) n = n + 1;
    }

    m2 = ind.genome2.mutationsOfType(mt);
    if (size(m2) > 0) {
        if (sum(m2.position == pos) > 0) n = n + 1;
    }

    return n;
}

function (integer) hapIndex(object<Haplosome> g)
{
    hasA2 = F;
    hasB2 = F;

    a = g.mutationsOfType(mA2);
    if (size(a) > 0) {
        if (sum(a.position == posA) > 0) hasA2 = T;
    }

    b = g.mutationsOfType(mB2);
    if (size(b) > 0) {
        if (sum(b.position == posB) > 0) hasB2 = T;
    }

    if (hasA2) {
        if (hasB2) return 4;
        return 3;
    }

    if (hasB2) return 2;
    return 1;
}

function (numeric) directSelectionMultiplier(object<Individual> ind)
{
    nA2 = countDerived(ind, mA2, posA);
    nB2 = countDerived(ind, mB2, posB);
    return oneLocusMult(nA2) * oneLocusMult(nB2);
}

function (numeric) orleachBDMIMultiplier(object<Individual> ind)
{
    i = hapIndex(ind.genome1);
    j = hapIndex(ind.genome2);

    if (i > j) {
        tmp = i;
        i = j;
        j = tmp;
    }

    one_hs = 1.0 + h*s;
    one_s  = 1.0 + s;

    e_single = (1.0 - hb*sb);
    e_double = (1.0 - hb*kb*sb);
    e_full   = (1.0 - sb);

    w = 1.0;

    if (i == 1) {
        if (j == 1) w = 1.0;
        else if (j == 2) w = 1.0;
        else if (j == 3) w = one_hs;
        else if (j == 4) w = one_hs * e_double;
    }
    else if (i == 2) {
        if (j == 2) w = 1.0;
        else if (j == 3) w = one_hs * e_double;
        else if (j == 4) w = one_hs * e_single;
    }
    else if (i == 3) {
        if (j == 3) w = one_s;
        else if (j == 4) w = one_s * e_single;
    }
    else if (i == 4) {
        if (j == 4) w = one_s * e_full;
    }

    return w;
}

function (void) migrateFlaggedHybrids(void)
{
    migrants = c();

    for (ind in c(p1.individuals, p2.individuals)) {
        flag = ind.getValue("migrateToP3");
        if (!isNULL(flag)) {
            if (flag) migrants = c(migrants, ind);
        }
    }

    if (size(migrants) > 0) {
        p3.takeMigrants(migrants);
        for (ind in migrants) ind.setValue("migrateToP3", F);
    }
}

function (void) applyCompetition(numeric K1, numeric K2, numeric K3)
{
    if (p1.individualCount > 0) {
        comp = c_p1 * (
            (p1.individualCount / K1) +
            alpha_p1_p2 * (p2.individualCount / K2) +
            alpha_pX_p3 * (p3.individualCount / K3)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p1.individuals) ind.fitnessScaling = base;
    }

    if (p2.individualCount > 0) {
        comp = c_p2 * (
            (p2.individualCount / K2) +
            alpha_p2_p1 * (p1.individualCount / K1) +
            alpha_pX_p3 * (p3.individualCount / K3)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p2.individuals) ind.fitnessScaling = base;
    }

    if (p3.individualCount > 0) {
        comp = c_p3 * (
            (p3.individualCount / K3) +
            alpha_p3_p1 * (p1.individualCount / K1) +
            alpha_p3_p2 * (p2.individualCount / K2)
        );
        base = 1.0 - comp;
        if (base < 0.01) base = 0.01;
        for (ind in p3.individuals) ind.fitnessScaling = base;
    }
}

function (void) applyOrleachBDMI(void)
{
    for (pop in sim.subpopulations) {
        for (ind in pop.individuals) {
            w_dir  = directSelectionMultiplier(ind);
            w_bdmi = orleachBDMIMultiplier(ind);
            ind.setValue("w_bdmi", w_bdmi);
            ind.fitnessScaling = ind.fitnessScaling * w_dir * w_bdmi;
            if (ind.fitnessScaling < 0.01) ind.fitnessScaling = 0.01;
        }
    }
}


//main script

initialize()
{
    initializeSLiMModelType("nonWF");
    initializeSLiMOptions(keepPedigrees=F);

    defineConstant("L", 100000);
    defineConstant("posA", 20000);
    defineConstant("posB", 70000);

    initializeMutationType("mA2", 0.5, "f", 0.0);
    initializeMutationType("mB2", 0.5, "f", 0.0);
    mA2.convertToSubstitution = F;
    mB2.convertToSubstitution = F;

    initializeGenomicElementType("g1", c(mA2, mB2), c(0.5, 0.5));
    initializeGenomicElement(g1, 0, L-1);

    defineConstant("MU", 0.0);
    initializeMutationRate(MU);
    initializeRecombinationRate(1e-3);

    defineConstant("K_total", 2500.0);
    defineConstant("K_prop_p1", 0.38375);
    defineConstant("K_prop_p2", 0.38375);
    defineConstant("K_prop_p3", 0.23250);

    defineConstant("maxOvules_p1p2", 12);
    defineConstant("maxOvules_p3",   7);
    defineConstant("hybridizationRate", 0.05);

    defineConstant("dd_rate0", 0.75);
    defineConstant("dd_c",     2.0);
    defineConstant("dd_floor", 0.01);

    defineConstant("alpha_p1_p2", 0.0);
    defineConstant("alpha_p2_p1", 0.0);
    defineConstant("alpha_pX_p3", 0.0);
    defineConstant("alpha_p3_p1", 0.0);
    defineConstant("alpha_p3_p2", 0.0);

    defineConstant("c_p1", 0.3);
    defineConstant("c_p2", 0.3);
    defineConstant("c_p3", 0.5);

    defineConstant("surv_k", 3.0);
    defineConstant("surv_theta", 0.6);

    defineConstant("s",  0.10);
    defineConstant("h",  0.50);
    defineConstant("sb", 0.30);
    defineConstant("hb", 0.50);
    defineConstant("kb", 1.00);

    defineConstant("T_max", 150);
    defineConstant("OUTFILE", "output_orleach_bdmi.txt");
}

1 early()
{
    sim.addSubpop("p1", 100);
    sim.addSubpop("p2", 150);
    sim.addSubpop("p3", 0);

    writeFile(OUTFILE,
        "gen\tN1\tN2\tN3\tmeanW_p1\tmeanW_p2\tmeanW_p3\tmeanBDMI_p3\tK1\tK2\tK3\n",
        append=F);

    for (ind in p1.individuals) {
        addAllele(ind.genome1, mA2, posA);
        addAllele(ind.genome2, mA2, posA);
        ind.setValue("age", 0);
    }

    for (ind in p2.individuals) {
        addAllele(ind.genome1, mB2, posB);
        addAllele(ind.genome2, mB2, posB);
        ind.setValue("age", 0);
    }
}

reproduction()
{
    totalPop = p1.individualCount + p2.individualCount + p3.individualCount;
    density  = totalPop / K_total;

    fertilizationRate = max(dd_rate0 * exp(-dd_c * density), dd_floor);
    clonalSuccessRate = fertilizationRate;

    if (totalPop >= K_total) return;

    if (subpop == p1) {
        n = min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10);
        for (i in seqLen(n)) {
            if (p2.individualCount > 0 & runif(1) < hybridizationRate) {
                mate = sample(p2.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("migrateToP3", T);
                kid.setValue("age", 0);
            } else {
                mate = sample(p1.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("age", 0);
            }
        }
        return;
    }

    if (subpop == p2) {
        n = min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10);
        for (i in seqLen(n)) {
            if (p1.individualCount > 0 & runif(1) < hybridizationRate) {
                mate = sample(p1.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("migrateToP3", T);
                kid.setValue("age", 0);
            } else {
                mate = sample(p2.individuals, 1);
                kid  = subpop.addCrossed(individual, mate);
                kid.setValue("age", 0);
            }
        }
        return;
    }

    if (subpop == p3) {
        n = min(rbinom(1, maxOvules_p3, clonalSuccessRate), 10);
        for (i in seqLen(n)) {
            kid = subpop.addCloned(individual);
            kid.setValue("age", 0);
        }
        return;
    }
}

early()
{
    migrateFlaggedHybrids();

    K1 = K_total * K_prop_p1;
    K2 = K_total * K_prop_p2;
    K3 = K_total * K_prop_p3;

    applyCompetition(K1, K2, K3);
    applyOrleachBDMI();

    sim.setValue("K1", K1);
    sim.setValue("K2", K2);
    sim.setValue("K3", K3);
}

survival(p1)
{
    w = individual.fitnessScaling;
    return 1.0 / (1.0 + exp(-surv_k * (w - surv_theta)));
}

survival(p2)
{
    w = individual.fitnessScaling;
    return 1.0 / (1.0 + exp(-surv_k * (w - surv_theta)));
}

survival(p3)
{
    w = individual.fitnessScaling;
    return 1.0 / (1.0 + exp(-surv_k * (w - surv_theta)));
}

late()
{
    for (ind in sim.subpopulations.individuals) {
        a = ind.getValue("age");
        if (isNULL(a)) a = 0;
        ind.setValue("age", a + 1);
    }

    meanW1 = p1.individualCount > 0 ? mean(p1.individuals.fitnessScaling) : 0.0;
    meanW2 = p2.individualCount > 0 ? mean(p2.individuals.fitnessScaling) : 0.0;
    meanW3 = p3.individualCount > 0 ? mean(p3.individuals.fitnessScaling) : 0.0;

    meanBDMIp3 = 0.0;
    if (p3.individualCount > 0) {
        sumBD = 0.0;
        for (ind in p3.individuals) {
            v = ind.getValue("w_bdmi");
            if (isNULL(v)) v = 1.0;
            sumBD = sumBD + v;
        }
        meanBDMIp3 = sumBD / p3.individualCount;
    }

    K1 = sim.getValue("K1");
    K2 = sim.getValue("K2");
    K3 = sim.getValue("K3");

    writeFile(OUTFILE,
        sim.cycle + "\t" +
        p1.individualCount + "\t" +
        p2.individualCount + "\t" +
        p3.individualCount + "\t" +
        meanW1 + "\t" + meanW2 + "\t" + meanW3 + "\t" +
        meanBDMIp3 + "\t" + K1 + "\t" + K2 + "\t" + K3 + "\n",
        append=T);

    if (sim.cycle >= T_max) sim.simulationFinished();
}
