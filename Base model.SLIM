//////////////////////////////
//  UTILITY FUNCTIONS

function (void) addAllele(object<Haplosome> g, object<MutationType> mt, integer pos)
{
	muts = g.mutationsOfType(mt);
	if (size(muts) > 0) {
		if (sum(muts.position == pos) > 0) return;
	}
	g.addNewDrawnMutation(mt, pos);
}

// ---- Trait inheritance: mid-parent + noise (placeholder quantitative genetics)
function (void) setOffspringTrait(object<Individual> kid, object<Individual> mom, object<Individual> dad)
{
	z1 = mom.getValue("z");
	z2 = dad.getValue("z");
	if (isNULL(z1)) z1 = 0.0;
	if (isNULL(z2)) z2 = 0.0;

	// mid-parent + Gaussian noise
	kid.setValue("z", (z1 + z2)/2.0 + rnorm(1, 0.0, sigma_z));
	kid.setSpatialPosition(c(kid.getValue("z"), 0.0));
}

// ---- ASSORTATIVE mate choice by trait z (prefer similar z)
function (object<Individual>) chooseMateAssort(object<Individual> focal, object<Individual> candidates)
{
	if (size(candidates) == 0)
		return NULL;

	zf = focal.getValue("z");
	if (isNULL(zf)) zf = 0.0;

	cands = c();
	weights = c();

	for (m in candidates) {
		// optional self-exclusion to reduce selfing (Eidos has no 'continue')
		if (!(excludeSelf & (m == focal))) {

			zm = m.getValue("z");
			if (isNULL(zm)) zm = 0.0;

			dz = zf - zm;
			w = exp(-(dz*dz) / (2.0*sigma_m*sigma_m));  // similar -> ~1, different -> ~0
			if (w < epsilon_w) w = epsilon_w;

			cands = c(cands, m);
			weights = c(weights, w);
		}
	}

	// If self was excluded and nothing left, fall back to uniform from original pool
	if (size(cands) == 0)
		return sample(candidates, 1);

	// Safety fallback
	if (sum(weights) <= 0.0)
		return sample(cands, 1);

	return sample(cands, 1, weights=weights);
}

function (integer) hapIndex(object<Haplosome> g)
{
	hasA2 = F;
	hasB2 = F;

	a = g.mutationsOfType(m1);
	if (size(a) > 0)
		if (sum(a.position == posA) > 0) hasA2 = T;

	b = g.mutationsOfType(m2);
	if (size(b) > 0)
		if (sum(b.position == posB) > 0) hasB2 = T;

	if (hasA2) {
		if (hasB2) return 4;
		return 3;
	}
	if (hasB2) return 2;
	return 1;
}

function (numeric) orleachBDMIMultiplier(object<Individual> ind)
{
	i = hapIndex(ind.haploidGenome1);
	j = hapIndex(ind.haploidGenome2);

	if (i > j) { tmp = i; i = j; j = tmp; }

	one_hs = 1.0 + h*s;
	one_s  = 1.0 + s;

	e_single = (1.0 - hb*sb);
	e_double = (1.0 - hb*kb*sb);
	e_full   = (1.0 - sb);

	w = 1.0;

	if (i == 1) {
		if (j == 1) w = 1.0;
		else if (j == 2) w = 1.0;
		else if (j == 3) w = one_hs;
		else if (j == 4) w = one_hs * e_double;
	}
	else if (i == 2) {
		if (j == 2) w = 1.0;
		else if (j == 3) w = one_hs * e_double;
		else if (j == 4) w = one_hs * e_single;
	}
	else if (i == 3) {
		if (j == 3) w = one_s;
		else if (j == 4) w = one_s * e_single;
	}
	else { // i == 4
		if (j == 4) w = one_s * e_full;
	}

	return w;
}

// Move hybrid-flagged offspring from p1/p2 into p3
function (void) migrateFlaggedHybrids(void)
{
	migrants = c();

	for (ind in c(p1.individuals, p2.individuals)) {
		flag = ind.getValue("migrateToP3");
		if (!isNULL(flag))
			if (flag) migrants = c(migrants, ind);
	}

	if (size(migrants) > 0) {
		p3.takeMigrants(migrants);
		for (ind in migrants)
			ind.setValue("migrateToP3", F);
	}
}

// MacArthur-style trait-overlap competition:
//   D_i = sum_j exp(-(z_i - z_j)^2 / (2*sigma_c^2))
//   w_comp,i = exp(-gamma_comp * D_i)
// Implemented via InteractionType i1 using x-position = z, y=0
function (void) applyMacArthurCompetition(void)
{
	// Evaluate Gaussian overlap kernel across all individuals
	i1.evaluate(sim.subpopulations);

	// Convert crowding -> w_comp, set fitnessScaling
	for (pop in sim.subpopulations) {
		for (ind in pop.individuals) {
			Di = i1.totalOfNeighborStrengths(ind);
			w_comp = exp(-gamma_comp * Di);

			if (w_comp < 0.01) w_comp = 0.01;
			ind.fitnessScaling = w_comp;
		}
	}
}

// Apply BDMI multiplicatively to existing fitnessScaling (which already holds competition)
function (void) applyOrleachBDMI(void)
{
	for (pop in sim.subpopulations) {
		for (ind in pop.individuals) {
			w_bdmi = orleachBDMIMultiplier(ind);

			ind.fitnessScaling = ind.fitnessScaling * w_bdmi;
			if (ind.fitnessScaling < 0.01) ind.fitnessScaling = 0.01;
		}
	}
}


//////////////////////////////
//  SURVIVAL (ANNUAL: all adults die; viability selection on juveniles)

survival()
{
	// annual: all older individuals die
	if (individual.age > 0)
		return F;

	// viability selection on age-0 cohort
	p = individual.fitnessScaling;
	if (p < 0.01) p = 0.01;
	if (p > 0.99) p = 0.99;
	return (runif(1) < p);
}


//////////////////////////////
//  INITIALIZE

initialize()
{
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=F, dimensionality="xy");

	// genome / BDMI loci
	defineConstant("L", 100000);
	defineConstant("posA", 20000);
	defineConstant("posB", 70000);

	initializeMutationType("m1", 0.5, "f", 0.0);  // A2
	initializeMutationType("m2", 0.5, "f", 0.0);  // B2
	m1.convertToSubstitution = F;
	m2.convertToSubstitution = F;

	initializeGenomicElementType("g1", c(m1, m2), c(0.5, 0.5));
	initializeGenomicElement(g1, 0, L-1);

	defineConstant("MU", 0.0);
	initializeMutationRate(MU);
	initializeRecombinationRate(1e-3);

	// fecundity parameters
	defineConstant("maxOvules_p1p2", 12);
	defineConstant("maxOvules_p3",   7);
	defineConstant("dd_rate0", 0.75);           // constant fertilization rate

	// hybridization attempts
	defineConstant("hybridizationRate", 0.05);

	// ---- MacArthur competition parameters (trait overlap kernel)
	defineConstant("sigma_c",    0.20);  // niche width in trait space
	defineConstant("maxDist_c", 0.60);  // 3 * 0.20
	defineConstant("gamma_comp", 0.02);  // strength: crowding -> viability

	// trait inheritance noise
	defineConstant("sigma_z", 0.05);

	// ---- ASSORTATIVE mate choice parameters
	defineConstant("sigma_m",    0.15);  // smaller = stronger assortative
	defineConstant("epsilon_w",  1e-6);
	defineConstant("excludeSelf", T);

	// Gaussian kernel competition in "xy" space (we'll place individuals at (z,0))
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=maxDist_c);
	i1.setInteractionFunction("n", 1.0, sigma_c);  // neighbor strength = exp(-d^2/(2*sigma_c^2))

	// BDMI parameters
	defineConstant("s",  0.10);
	defineConstant("h",  0.50);
	defineConstant("sb", 0.30);
	defineConstant("hb", 0.50);
	defineConstant("kb", 1.00);

	defineConstant("T_max", 2000);
	defineConstant("OUTFILE", "output_base_annual_macarthur.txt");
}


//////////////////////////////
//  SETUP (FOUNDERS + OUTPUT) — FIRST()

1 first()
{
    // create founding populations
    sim.addSubpop("p1", 100);
    sim.addSubpop("p2", 150);
    sim.addSubpop("p3", 0);

    // fix parental genotypes
    for (ind in p1.individuals) {
        addAllele(ind.haploidGenome1, m1, posA);
        addAllele(ind.haploidGenome2, m1, posA);
    }
    for (ind in p2.individuals) {
        addAllele(ind.haploidGenome1, m2, posB);
        addAllele(ind.haploidGenome2, m2, posB);
    }

    // assign initial trait values
    for (ind in p1.individuals) ind.setValue("z", -0.5);
    for (ind in p2.individuals) ind.setValue("z",  0.5);

    // ★ ADD THESE LINES RIGHT HERE ★
    for (ind in p1.individuals) ind.setSpatialPosition(c(ind.getValue("z"), 0.0));
    for (ind in p2.individuals) ind.setSpatialPosition(c(ind.getValue("z"), 0.0));

	writeFile(OUTFILE,
    "gen\tN1\tN2\tN3\t" +
    "pA2_p1\tpB2_p1\tpA2_p2\tpB2_p2\tpA2_p3\tpB2_p3\n",
    append=F);

}

//////////////////////////////
//  REPRODUCTION (ANNUAL: create offspring; adults die via survival())

reproduction()
{
	// Constant fertilization rate (no density dependence)
	fertilizationRate = dd_rate0;

	// p1: within p1 normally; hybridize with p2 or p3 at hybridizationRate -> offspring migrates to p3
	if (subpop == p1) {
		n = asInteger(min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doHybrid = (runif(1) < hybridizationRate);

			if (doHybrid) {
				candidates = c();
				if (p2.individualCount > 0) candidates = c(candidates, p2.individuals);
				if (p3.individualCount > 0) candidates = c(candidates, p3.individuals);

				if (size(candidates) > 0) {
					mate = chooseMateAssort(individual, candidates);
					kid  = subpop.addCrossed(individual, mate);
					kid.setValue("migrateToP3", T);
					setOffspringTrait(kid, individual, mate);
				} else {
					mate = chooseMateAssort(individual, p1.individuals);
					kid  = subpop.addCrossed(individual, mate);
					setOffspringTrait(kid, individual, mate);
				}
			} else {
				mate = chooseMateAssort(individual, p1.individuals);
				kid  = subpop.addCrossed(individual, mate);
				setOffspringTrait(kid, individual, mate);
			}
		}
		return;
	}

	// p2: within p2 normally; hybridize with p1 or p3 at hybridizationRate -> offspring migrates to p3
	if (subpop == p2) {
		n = asInteger(min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doHybrid = (runif(1) < hybridizationRate);

			if (doHybrid) {
				candidates = c();
				if (p1.individualCount > 0) candidates = c(candidates, p1.individuals);
				if (p3.individualCount > 0) candidates = c(candidates, p3.individuals);

				if (size(candidates) > 0) {
					mate = chooseMateAssort(individual, candidates);
					kid  = subpop.addCrossed(individual, mate);
					kid.setValue("migrateToP3", T);
					setOffspringTrait(kid, individual, mate);
				} else {
					mate = chooseMateAssort(individual, p2.individuals);
					kid  = subpop.addCrossed(individual, mate);
					setOffspringTrait(kid, individual, mate);
				}
			} else {
				mate = chooseMateAssort(individual, p2.individuals);
				kid  = subpop.addCrossed(individual, mate);
				setOffspringTrait(kid, individual, mate);
			}
		}
		return;
	}

	// p3: sexual; mate within p3 normally; backcross to p1/p2 at hybridizationRate; offspring stays in p3
	if (subpop == p3) {
		n = asInteger(min(rbinom(1, maxOvules_p3, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doBackcross = (runif(1) < hybridizationRate);

			if (doBackcross) {
				candidates = c();
				if (p1.individualCount > 0) candidates = c(candidates, p1.individuals);
				if (p2.individualCount > 0) candidates = c(candidates, p2.individuals);

				if (size(candidates) > 0)
					mate = chooseMateAssort(individual, candidates);
				else
					mate = chooseMateAssort(individual, p3.individuals);
			} else {
				mate = chooseMateAssort(individual, p3.individuals);
			}

			kid = subpop.addCrossed(individual, mate);
			setOffspringTrait(kid, individual, mate);
		}
		return;
	}
}


//////////////////////////////
//  FITNESS ASSEMBLY (EACH GEN: MIGRATE -> RESET -> MACARTHUR COMP -> BDMI)

early()
{
	// 1) move hybrid offspring into p3 (must happen before fitness assembly)
	migrateFlaggedHybrids();

	// 2) reset fitnessScaling so it doesn't accumulate
	for (pop in sim.subpopulations)
		for (ind in pop.individuals)
			ind.fitnessScaling = 1.0;

	// 3) assemble multiplicative fitnessScaling = w_comp(trait overlap) * w_bdmi
	applyMacArthurCompetition();
	applyOrleachBDMI();
}


//////////////////////////////
//  OUTPUT + STOP

late()
{
    // Fast allele frequencies (no explicit loops over individuals)
    pA2_p1 = sim.mutationFrequencies(p1, sim.mutationsOfType(m1)); if (size(pA2_p1)==0) pA2_p1=0.0;
    pB2_p1 = sim.mutationFrequencies(p1, sim.mutationsOfType(m2)); if (size(pB2_p1)==0) pB2_p1=0.0;

    pA2_p2 = sim.mutationFrequencies(p2, sim.mutationsOfType(m1)); if (size(pA2_p2)==0) pA2_p2=0.0;
    pB2_p2 = sim.mutationFrequencies(p2, sim.mutationsOfType(m2)); if (size(pB2_p2)==0) pB2_p2=0.0;

    pA2_p3 = sim.mutationFrequencies(p3, sim.mutationsOfType(m1)); if (size(pA2_p3)==0) pA2_p3=0.0;
    pB2_p3 = sim.mutationFrequencies(p3, sim.mutationsOfType(m2)); if (size(pB2_p3)==0) pB2_p3=0.0;

    writeFile(OUTFILE,
        sim.cycle + "\t" +
        p1.individualCount + "\t" +
        p2.individualCount + "\t" +
        p3.individualCount + "\t" +
        pA2_p1 + "\t" + pB2_p1 + "\t" +
        pA2_p2 + "\t" + pB2_p2 + "\t" +
        pA2_p3 + "\t" + pB2_p3 + "\n",
        append=T);
}


2000 late()
{
	sim.simulationFinished();
}
