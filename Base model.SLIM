// ============================================================
//  3-pop nonWF ANNUAL hybrid model (SLiM 5.0)
//  Purpose: annual life cycle; MacArthur trait-overlap competition × 2-locus BDMI (viability);
//           hybrids migrate to p3; p3 is sexual with backcrossing
// ============================================================


//////////////////////////////
//  UTILITY FUNCTIONS

function (void) addAllele(object<Haplosome> g, object<MutationType> mt, integer pos)
{
	muts = g.mutationsOfType(mt);
	if (size(muts) > 0) {
		if (sum(muts.position == pos) > 0) return;
	}
	g.addNewDrawnMutation(mt, pos);
}

// ---- Trait inheritance: mid-parent + noise (placeholder quantitative genetics)
function (void) setOffspringTrait(object<Individual> kid, object<Individual> mom, object<Individual> dad)
{
	z1 = mom.getValue("z");
	z2 = dad.getValue("z");
	if (isNULL(z1)) z1 = 0.0;
	if (isNULL(z2)) z2 = 0.0;

	// mid-parent + Gaussian noise
	kid.setValue("z", (z1 + z2)/2.0 + rnorm(1, 0.0, sigma_z));
}

function (integer) hapIndex(object<Haplosome> g)
{
	hasA2 = F;
	hasB2 = F;

	a = g.mutationsOfType(m1);
	if (size(a) > 0)
		if (sum(a.position == posA) > 0) hasA2 = T;

	b = g.mutationsOfType(m2);
	if (size(b) > 0)
		if (sum(b.position == posB) > 0) hasB2 = T;

	if (hasA2) {
		if (hasB2) return 4;
		return 3;
	}
	if (hasB2) return 2;
	return 1;
}

function (numeric) orleachBDMIMultiplier(object<Individual> ind)
{
	i = hapIndex(ind.haploidGenome1);
	j = hapIndex(ind.haploidGenome2);

	if (i > j) { tmp = i; i = j; j = tmp; }

	one_hs = 1.0 + h*s;
	one_s  = 1.0 + s;

	e_single = (1.0 - hb*sb);
	e_double = (1.0 - hb*kb*sb);
	e_full   = (1.0 - sb);

	w = 1.0;

	if (i == 1) {
		if (j == 1) w = 1.0;
		else if (j == 2) w = 1.0;
		else if (j == 3) w = one_hs;
		else if (j == 4) w = one_hs * e_double;
	}
	else if (i == 2) {
		if (j == 2) w = 1.0;
		else if (j == 3) w = one_hs * e_double;
		else if (j == 4) w = one_hs * e_single;
	}
	else if (i == 3) {
		if (j == 3) w = one_s;
		else if (j == 4) w = one_s * e_single;
	}
	else { // i == 4
		if (j == 4) w = one_s * e_full;
	}

	return w;
}

// Move hybrid-flagged offspring from p1/p2 into p3
function (void) migrateFlaggedHybrids(void)
{
	migrants = c();

	for (ind in c(p1.individuals, p2.individuals)) {
		flag = ind.getValue("migrateToP3");
		if (!isNULL(flag))
			if (flag) migrants = c(migrants, ind);
	}

	if (size(migrants) > 0) {
		p3.takeMigrants(migrants);
		for (ind in migrants)
			ind.setValue("migrateToP3", F);
	}
}

// MacArthur-style trait-overlap competition:
//   D_i = sum_j exp(-(z_i - z_j)^2 / (2*sigma_c^2))
//   w_comp,i = exp(-gamma_comp * D_i)
// Implemented via InteractionType i1 using x-position = z, y=0
function (void) applyMacArthurCompetition(void)
{
	// Map trait z -> spatial x coordinate
	for (pop in sim.subpopulations) {
		for (ind in pop.individuals) {
			z = ind.getValue("z");
			if (isNULL(z)) z = 0.0;
			ind.setSpatialPosition(c(z, 0.0));
		}
	}

	// Evaluate Gaussian overlap kernel across all individuals
	i1.evaluate(sim.subpopulations);

	// Convert crowding -> w_comp, set fitnessScaling
	for (pop in sim.subpopulations) {
		for (ind in pop.individuals) {
			Di = i1.totalOfNeighborStrengths(ind);
			w_comp = exp(-gamma_comp * Di);

			if (w_comp < 0.01) w_comp = 0.01;
			ind.fitnessScaling = w_comp;
		}
	}
}

// Apply BDMI multiplicatively to existing fitnessScaling (which already holds competition)
function (void) applyOrleachBDMI(void)
{
	for (pop in sim.subpopulations) {
		for (ind in pop.individuals) {
			w_bdmi = orleachBDMIMultiplier(ind);
			ind.setValue("w_bdmi", w_bdmi);

			ind.fitnessScaling = ind.fitnessScaling * w_bdmi;
			if (ind.fitnessScaling < 0.01) ind.fitnessScaling = 0.01;
		}
	}
}


//////////////////////////////
//  SURVIVAL (ANNUAL: all adults die; viability selection on juveniles)

survival()
{
	// annual: all older individuals die
	if (individual.age > 0)
		return F;

	// viability selection on age-0 cohort
	p = individual.fitnessScaling;
	if (p < 0.01) p = 0.01;
	if (p > 0.99) p = 0.99;
	return (runif(1) < p);
}


//////////////////////////////
//  INITIALIZE

initialize()
{
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=F, dimensionality="xy");

	// genome / BDMI loci
	defineConstant("L", 100000);
	defineConstant("posA", 20000);
	defineConstant("posB", 70000);

	initializeMutationType("m1", 0.5, "f", 0.0);  // A2
	initializeMutationType("m2", 0.5, "f", 0.0);  // B2
	m1.convertToSubstitution = F;
	m2.convertToSubstitution = F;

	initializeGenomicElementType("g1", c(m1, m2), c(0.5, 0.5));
	initializeGenomicElement(g1, 0, L-1);

	defineConstant("MU", 0.0);
	initializeMutationRate(MU);
	initializeRecombinationRate(1e-3);

	// fecundity density dependence (kept as-is)
	defineConstant("K_total", 2500.0);
	defineConstant("K_prop_p1", 0.38375);
	defineConstant("K_prop_p2", 0.38375);
	defineConstant("K_prop_p3", 0.23250);

	defineConstant("maxOvules_p1p2", 12);
	defineConstant("maxOvules_p3",   7);

	defineConstant("hybridizationRate", 0.05);

	defineConstant("dd_rate0", 0.75);
	defineConstant("dd_c",     2.0);
	defineConstant("dd_floor", 0.01);

	// ---- MacArthur competition parameters (trait overlap kernel)
	defineConstant("sigma_c",   0.20);  // niche width in trait space
	defineConstant("maxDist_c", 1.00);  // truncate neighbor search beyond this |Δz|
	defineConstant("gamma_comp", 0.02); // strength: crowding -> viability

	// trait inheritance noise
	defineConstant("sigma_z", 0.05);

	// Gaussian kernel competition in "xy" space (we'll place individuals at (z,0))
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=maxDist_c);
	i1.setInteractionFunction("n", 1.0, sigma_c);  // neighbor strength = exp(-d^2/(2*sigma_c^2))

	// BDMI parameters
	defineConstant("s",  0.10);
	defineConstant("h",  0.50);
	defineConstant("sb", 0.30);
	defineConstant("hb", 0.50);
	defineConstant("kb", 1.00);

	defineConstant("T_max", 2000);
	defineConstant("OUTFILE", "output_base_annual_macarthur.txt");
}


//////////////////////////////
//  SETUP (FOUNDERS + OUTPUT) — FIRST()

1 first()
{
	// ---- create founding populations BEFORE first reproduction
	sim.addSubpop("p1", 100);
	sim.addSubpop("p2", 150);
	sim.addSubpop("p3", 0);

	// ---- output header
	writeFile(OUTFILE,
		"gen\tN1\tN2\tN3\tmeanW_p1\tmeanW_p2\tmeanW_p3\tmeanBDMI_p3\tK1\tK2\tK3\n",
		append=F);

	// ---- fix parental genotypes
	for (ind in p1.individuals) {
		addAllele(ind.haploidGenome1, m1, posA);
		addAllele(ind.haploidGenome2, m1, posA);
	}
	for (ind in p2.individuals) {
		addAllele(ind.haploidGenome1, m2, posB);
		addAllele(ind.haploidGenome2, m2, posB);
	}

	// ---- initial trait means (parents start separated; change if you want overlap)
	for (ind in p1.individuals) ind.setValue("z", -0.5);
	for (ind in p2.individuals) ind.setValue("z",  0.5);
}


//////////////////////////////
//  REPRODUCTION (ANNUAL: create offspring; adults die via survival())

reproduction()
{
	totalPop = p1.individualCount + p2.individualCount + p3.individualCount;
	density  = totalPop / K_total;

	fertilizationRate = max(dd_rate0 * exp(-dd_c * density), dd_floor);

	// p1: within p1 normally; hybridize with p2 or p3 at hybridizationRate -> offspring migrates to p3
	if (subpop == p1) {
		n = asInteger(min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doHybrid = (runif(1) < hybridizationRate);

			if (doHybrid) {
				candidates = c();
				if (p2.individualCount > 0) candidates = c(candidates, p2.individuals);
				if (p3.individualCount > 0) candidates = c(candidates, p3.individuals);

				if (size(candidates) > 0) {
					mate = sample(candidates, 1);
					kid  = subpop.addCrossed(individual, mate);
					kid.setValue("migrateToP3", T);
					setOffspringTrait(kid, individual, mate);
				} else {
					mate = sample(p1.individuals, 1);
					kid  = subpop.addCrossed(individual, mate);
					setOffspringTrait(kid, individual, mate);
				}
			} else {
				mate = sample(p1.individuals, 1);
				kid  = subpop.addCrossed(individual, mate);
				setOffspringTrait(kid, individual, mate);
			}
		}
		return;
	}

	// p2: within p2 normally; hybridize with p1 or p3 at hybridizationRate -> offspring migrates to p3
	if (subpop == p2) {
		n = asInteger(min(rbinom(1, maxOvules_p1p2, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doHybrid = (runif(1) < hybridizationRate);

			if (doHybrid) {
				candidates = c();
				if (p1.individualCount > 0) candidates = c(candidates, p1.individuals);
				if (p3.individualCount > 0) candidates = c(candidates, p3.individuals);

				if (size(candidates) > 0) {
					mate = sample(candidates, 1);
					kid  = subpop.addCrossed(individual, mate);
					kid.setValue("migrateToP3", T);
					setOffspringTrait(kid, individual, mate);
				} else {
					mate = sample(p2.individuals, 1);
					kid  = subpop.addCrossed(individual, mate);
					setOffspringTrait(kid, individual, mate);
				}
			} else {
				mate = sample(p2.individuals, 1);
				kid  = subpop.addCrossed(individual, mate);
				setOffspringTrait(kid, individual, mate);
			}
		}
		return;
	}

	// p3: sexual; mate within p3 normally; backcross to p1/p2 at hybridizationRate; offspring stays in p3
	if (subpop == p3) {
		n = asInteger(min(rbinom(1, maxOvules_p3, fertilizationRate), 10));
		for (i in seqLen(n)) {
			doBackcross = (runif(1) < hybridizationRate);

			if (doBackcross) {
				candidates = c();
				if (p1.individualCount > 0) candidates = c(candidates, p1.individuals);
				if (p2.individualCount > 0) candidates = c(candidates, p2.individuals);

				if (size(candidates) > 0)
					mate = sample(candidates, 1);
				else
					mate = sample(p3.individuals, 1);
			} else {
				mate = sample(p3.individuals, 1);
			}

			kid = subpop.addCrossed(individual, mate);
			setOffspringTrait(kid, individual, mate);
		}
		return;
	}
}


//////////////////////////////
//  FITNESS ASSEMBLY (EACH GEN: MIGRATE -> RESET -> MACARTHUR COMP -> BDMI)

early()
{
	// 1) move hybrid offspring into p3 (must happen before fitness assembly)
	migrateFlaggedHybrids();

	// 2) reset fitnessScaling so it doesn't accumulate
	for (pop in sim.subpopulations)
		for (ind in pop.individuals)
			ind.fitnessScaling = 1.0;

	// 3) compute K's (kept for output / fecundity density, not used in competition now)
	K1 = K_total * K_prop_p1;
	K2 = K_total * K_prop_p2;
	K3 = K_total * K_prop_p3;

	// 4) assemble multiplicative fitnessScaling = w_comp(trait overlap) * w_bdmi
	applyMacArthurCompetition();
	applyOrleachBDMI();

	// 5) store for output()
	sim.setValue("K1", K1);
	sim.setValue("K2", K2);
	sim.setValue("K3", K3);
}


//////////////////////////////
//  OUTPUT + STOP

late()
{
	catn("LATE: cycle=" + sim.cycle + " N=" + (p1.individualCount + p2.individualCount + p3.individualCount));

	// ---- Mean fitnessScaling per population
	if (p1.individualCount > 0) meanW1 = mean(p1.individuals.fitnessScaling); else meanW1 = 0.0;
	if (p2.individualCount > 0) meanW2 = mean(p2.individuals.fitnessScaling); else meanW2 = 0.0;
	if (p3.individualCount > 0) meanW3 = mean(p3.individuals.fitnessScaling); else meanW3 = 0.0;

	// ---- Mean BDMI in p3
	meanBDMIp3 = 0.0;
	if (p3.individualCount > 0) {
		sumBD = 0.0;
		for (ind in p3.individuals) {
			v = ind.getValue("w_bdmi");
			if (isNULL(v)) v = 1.0;
			sumBD = sumBD + v;
		}
		meanBDMIp3 = sumBD / p3.individualCount;
	}

	// ---- K values (stored in early())
	K1 = sim.getValue("K1");
	K2 = sim.getValue("K2");
	K3 = sim.getValue("K3");

	writeFile(OUTFILE,
		sim.cycle + "\t" +
		p1.individualCount + "\t" +
		p2.individualCount + "\t" +
		p3.individualCount + "\t" +
		meanW1 + "\t" + meanW2 + "\t" + meanW3 + "\t" +
		meanBDMIp3 + "\t" + K1 + "\t" + K2 + "\t" + K3 + "\n",
		append=T);
}

2000 late()
{
	sim.simulationFinished();
}

